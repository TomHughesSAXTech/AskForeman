<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ask Foreman - Admin Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --construction-orange: #ff6b35;
            --safety-yellow: #ffc107;
            --concrete-gray: #424242;
            --steel-gray: #616161;
            --blueprint-blue: #1565c0;
            --hi-vis-green: #76ff03;
            --warning-red: #d32f2f;
            --white: #ffffff;
            --light-gray: #f5f5f5;
            --medium-gray: #e0e0e0;
            --dark-gray: #212121;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-lg: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #37474f 0%, #263238 100%);
            min-height: 100vh;
        }

        /* Login Screen */
        .login-container {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .login-box {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            box-shadow: var(--shadow-lg);
            width: 90%;
            max-width: 400px;
        }

        .login-box h2 {
            color: var(--concrete-gray);
            margin-bottom: 1.5rem;
            text-align: center;
        }

        .login-box input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 2px solid var(--medium-gray);
            border-radius: 5px;
            font-size: 1rem;
        }

        .login-box button {
            width: 100%;
            padding: 0.75rem;
            background: linear-gradient(135deg, var(--safety-yellow), #f57f17);
            color: var(--dark-gray);
            border: none;
            border-radius: 5px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
        }

        .error-message {
            color: var(--warning-red);
            text-align: center;
            margin-top: 1rem;
            display: none;
        }

        /* Admin Panel */
        .admin-container {
            display: none;
            flex-direction: column;
            min-height: 100vh;
        }

        .header {
            background: linear-gradient(135deg, var(--dark-gray) 0%, var(--concrete-gray) 100%);
            color: white;
            padding: 1rem 2rem;
            box-shadow: var(--shadow-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 4px solid var(--warning-red);
        }

        .header h1 {
            font-size: 1.8rem;
            color: var(--safety-yellow);
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--safety-yellow), #f57f17);
            color: var(--dark-gray);
        }

        .btn-success {
            background: var(--hi-vis-green);
            color: var(--dark-gray);
        }

        .btn-danger {
            background: var(--warning-red);
            color: white;
        }

        .btn-small {
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
        }

        .content {
            flex: 1;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 2rem;
            max-width: 1600px;
            margin: 0 auto;
            width: 100%;
        }

        .panel {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: var(--shadow-lg);
        }

        .panel h2 {
            color: var(--concrete-gray);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--safety-yellow);
        }

        .client-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .client-item {
            padding: 1rem;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .client-item:hover {
            background: var(--light-gray);
            border-color: var(--construction-orange);
        }

        .client-item.selected {
            background: #fff3cd;
            border-color: var(--safety-yellow);
        }

        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid var(--medium-gray);
        }

        .tab {
            padding: 0.75rem 1.5rem;
            background: var(--light-gray);
            border: none;
            cursor: pointer;
            font-weight: 600;
            color: var(--steel-gray);
            border-radius: 5px 5px 0 0;
        }

        .tab.active {
            background: white;
            color: var(--concrete-gray);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            font-weight: 600;
            color: var(--concrete-gray);
            margin-bottom: 0.25rem;
        }

        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 0.5rem;
            border: 1px solid var(--medium-gray);
            border-radius: 5px;
        }

        .form-group textarea {
            min-height: 80px;
            resize: vertical;
        }

        .loading-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--safety-yellow);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .status-message {
            display: none;
            padding: 1rem;
            border-radius: 5px;
            margin-top: 1rem;
        }

        .status-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .status-warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }

        .document-table {
            width: 100%;
            border-collapse: collapse;
        }

        .document-table th,
        .document-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--medium-gray);
        }

        .document-table th {
            background: var(--light-gray);
            font-weight: 600;
        }

        .file-upload-area {
            border: 2px dashed var(--medium-gray);
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-upload-area:hover,
        .file-upload-area.dragover {
            background: #e3f2fd;
            border-color: var(--blueprint-blue);
        }

        .operation-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1rem;
        }

        .help-text {
            font-size: 0.85rem;
            color: var(--steel-gray);
            margin-top: 0.25rem;
        }

        .file-limit-warning {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 5px;
            padding: 0.75rem;
            margin-bottom: 1rem;
            color: #856404;
        }

        .file-limit-warning strong {
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="loginContainer" class="login-container">
        <div class="login-box">
            <h2>üîí Admin Access</h2>
            <input type="password" id="passwordInput" placeholder="Enter admin password" onkeypress="if(event.key==='Enter') login()">
            <button onclick="login()">Login</button>
            <div id="loginError" class="error-message">Invalid password. Please try again.</div>
        </div>
    </div>

    <!-- Admin Panel -->
    <div id="adminContainer" class="admin-container">
        <header class="header">
            <h1>üõ†Ô∏è Ask Foreman Admin Panel</h1>
            <div>
                <button class="btn btn-primary" onclick="window.location.href='index.html'">‚Üê Back to App</button>
                <button class="btn btn-danger" onclick="logout()">Logout</button>
            </div>
        </header>

        <div class="content">
            <!-- Client List Panel -->
            <div class="panel">
                <h2>üèóÔ∏è Client Projects</h2>
                <div class="client-list" id="clientList">
                    <!-- Client items will be loaded here -->
                </div>
            </div>

            <!-- Client Details Panel -->
            <div class="panel">
                <h2>üìã Client Management</h2>
                
                <!-- Tabs -->
                <div class="tabs">
                    <button class="tab active" onclick="switchTab('details')">Details</button>
                    <button class="tab" onclick="switchTab('documents')">Documents</button>
                    <button class="tab" onclick="switchTab('operations')">System Operations</button>
                </div>

                <!-- Details Tab -->
                <div id="detailsTab" class="tab-content active">
                    <div id="clientDetails">
                        <p style="color: var(--steel-gray); text-align: center; padding: 2rem;">
                            Select a client from the list to view details
                        </p>
                    </div>
                </div>

                <!-- Documents Tab -->
                <div id="documentsTab" class="tab-content">
                    <div id="documentManagement">
                        <p style="color: var(--steel-gray); text-align: center; padding: 2rem;">
                            Select a client to manage documents
                        </p>
                    </div>
                </div>

                <!-- Operations Tab -->
                <div id="operationsTab" class="tab-content">
                    <div class="mass-operations">
                        <h3>üîß System Operations</h3>
                        <div class="operation-buttons">
                            <div>
                                <button class="btn btn-primary" onclick="syncAzureStorage()" style="width: 100%;">
                                    ‚òÅÔ∏è Sync Azure Storage
                                </button>
                                <p class="help-text">Scan Azure for new clients and update document counts</p>
                            </div>
                            <div>
                                <button class="btn" onclick="exportClientData()" style="width: 100%; background: #6c757d; color: white;">
                                    üì• Export Client Data
                                </button>
                                <p class="help-text">Download client list as JSON</p>
                            </div>
                        </div>
                        
                        <!-- Index Management Section -->
                        <div style="margin-top: 2rem; padding: 1rem; background: #fff3e0; border-radius: 5px; border: 2px solid var(--safety-yellow);">
                            <h4>üîç Search Index Management</h4>
                            <div style="margin: 1rem 0;">
                                <button class="btn btn-primary" onclick="viewIndexContents()" style="margin-right: 0.5rem;">
                                    üìä View Index Contents
                                </button>
                                <button class="btn btn-primary" onclick="viewIndexContents(true)" style="margin-right: 0.5rem; background: #2196F3;">
                                    üîÑ Force Refresh Stats
                                </button>
                                <button class="btn btn-danger" onclick="confirmClearIndex()">
                                    üóëÔ∏è Clear Entire Index
                                </button>
                            </div>
                            <div id="indexStats" style="margin-top: 1rem; padding: 0.5rem; background: white; border-radius: 3px; display: none;">
                                <p><strong>Index Statistics:</strong></p>
                                <p id="indexDocCount">Documents: Loading...</p>
                                <p id="indexSize">Size: Loading...</p>
                                <p id="indexLastUpdate">Last Updated: Loading...</p>
                            </div>
                            <div id="indexContents" style="margin-top: 1rem; max-height: 400px; overflow-y: auto; display: none;">
                                <!-- Index contents will be loaded here -->
                            </div>
                        </div>
                        
                        <div style="margin-top: 2rem;">
                            <h4>üì§ Bulk Upload Documents</h4>
                            
                            <!-- File Limit Warning -->
                            <div class="file-limit-warning">
                                ‚ö†Ô∏è <strong>File Limit:</strong> Maximum 15 files per upload to prevent system overload.
                            </div>
                            
                            <!-- Global Category Selection -->
                <div style="margin-bottom: 1rem; padding: 1rem; background: var(--light-gray); border-radius: 5px;">
                                <p style="font-weight: 600; margin-bottom: 0.5rem;">Default Category for All Files:</p>
                                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;">
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="radio" name="uploadCategory" value="drawings" checked>
                                        <span>üìê Drawings</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="radio" name="uploadCategory" value="estimates">
                                        <span>üí∞ Estimates</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="radio" name="uploadCategory" value="proposals">
                                        <span>üìä Proposals</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="radio" name="uploadCategory" value="specs">
                                        <span>üìã Specs</span>
                                    </label>
                                    <label style="display: flex; align-items: center; gap: 0.5rem;">
                                        <input type="radio" name="uploadCategory" value="signed-contracts">
                                        <span>üìù Contracts</span>
                                    </label>
                                </div>
                            </div>
                            
                            <div class="file-upload-area" id="bulkUploadArea" onclick="document.getElementById('bulkFileInput').click()">
                                <p>üìÅ Drop files here or click to browse</p>
                                <p style="font-size: 0.9rem; color: var(--steel-gray);">Maximum 15 files at once ‚Ä¢ You can customize category for each file after selection</p>
                            </div>
                            <input type="file" id="bulkFileInput" multiple style="display: none;" onchange="handleBulkFilesWithPreview(event)">
                            
                            <!-- File Preview Area -->
                            <div id="filePreviewArea" style="display: none; margin-top: 1rem; padding: 1rem; background: var(--light-gray); border-radius: 5px;">
                                <h5 style="margin-bottom: 1rem;">üìã Files to Upload:</h5>
                                <div id="fileList"></div>
                                <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
                                    <button class="btn btn-success" onclick="uploadFilesWithCategories()">üì§ Upload All Files</button>
                                    <button class="btn btn-danger" onclick="clearFileSelection()">‚ùå Clear Selection</button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Status Messages -->
                <div id="statusMessage" class="status-message"></div>
            </div>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div style="text-align: center;">
            <div class="spinner"></div>
            <p id="loadingText" style="color: white; margin-top: 1rem;">Loading...</p>
        </div>
    </div>

    <script>
        // Configuration
        const ADMIN_PASSWORD = 'FCS2025!';
        const API_BASE = 'https://workflows.saxtechnology.com/webhook/ask-foreman';
        const AZURE_STORAGE = {
            account: 'saxtechfcs',
            container: 'fcs-clients',
            sasToken: '?sp=racwdl&st=2025-08-07T21:44:55Z&se=2030-08-08T05:59:55Z&spr=https&sv=2024-11-04&sr=c&sig=AeQA3cyePZQqGGmb6QPu5G4y1b0qB8Z5FIFZBdi6Cdo%3D'
        };
        const MAX_FILES_PER_UPLOAD = 15; // Maximum files allowed per bulk upload

        let selectedClient = null;
        let clients = [];

        // Authentication
        function login() {
            const password = document.getElementById('passwordInput').value;
            if (password === ADMIN_PASSWORD) {
                sessionStorage.setItem('adminAuth', 'true');
                document.getElementById('loginContainer').style.display = 'none';
                document.getElementById('adminContainer').style.display = 'flex';
                loadClients();
            } else {
                document.getElementById('loginError').style.display = 'block';
                document.getElementById('passwordInput').value = '';
            }
        }

        function logout() {
            sessionStorage.removeItem('adminAuth');
            window.location.reload();
        }

        // Check auth on load
        window.onload = function() {
            if (sessionStorage.getItem('adminAuth') === 'true') {
                document.getElementById('loginContainer').style.display = 'none';
                document.getElementById('adminContainer').style.display = 'flex';
                loadClients();
            }
        };

        // Tab switching
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }

        // Load clients from Azure
        async function loadClients() {
            showLoading('Loading clients...');
            try {
                const url = `https://${AZURE_STORAGE.account}.blob.core.windows.net/${AZURE_STORAGE.container}${AZURE_STORAGE.sasToken}&restype=container&comp=list&prefix=FCS-OriginalClients/&delimiter=/`;
                
                const response = await fetch(url);
                const xmlText = await response.text();
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const prefixes = xmlDoc.getElementsByTagName("BlobPrefix");
                
                clients = [];
                for (let i = 0; i < prefixes.length; i++) {
                    const nameElement = prefixes[i].getElementsByTagName("Name")[0];
                    if (nameElement) {
                        const fullPath = nameElement.textContent.replace(/\/$/, '');
                        const pathParts = fullPath.split('/');
                        if (pathParts.length >= 2 && pathParts[0] === 'FCS-OriginalClients') {
                            const clientName = pathParts[1];
                            clients.push({
                                id: clientName.toLowerCase(),
                                name: clientName,
                                folder: clientName,
                                projectType: 'Commercial',
                                description: ''
                            });
                        }
                    }
                }
                
                renderClients();
            } catch (error) {
                console.error('Error loading clients:', error);
                showStatus('error', 'Failed to load clients');
            } finally {
                hideLoading();
            }
        }

        function renderClients() {
            const listContainer = document.getElementById('clientList');
            listContainer.innerHTML = '';
            
            clients.forEach(client => {
                const item = document.createElement('div');
                item.className = 'client-item';
                item.onclick = () => selectClient(client);
                
                item.innerHTML = `
                    <div style="font-weight: 600; color: var(--concrete-gray);">${client.name}</div>
                    <div style="font-size: 0.9rem; color: var(--steel-gray);">
                        Type: ${client.projectType}
                    </div>
                `;
                
                listContainer.appendChild(item);
            });
        }

        function selectClient(client) {
            selectedClient = client;
            
            // Update UI selection
            document.querySelectorAll('.client-item').forEach(item => item.classList.remove('selected'));
            event.target.closest('.client-item').classList.add('selected');
            
            // Load client details
            loadClientDetails();
            loadClientDocuments();
        }

        async function loadClientDetails() {
            const detailsContainer = document.getElementById('clientDetails');
            
            // Load metadata from Azure Blob Storage (stored as JSON file)
            try {
                const metadataUrl = `https://${AZURE_STORAGE.account}.blob.core.windows.net/${AZURE_STORAGE.container}/FCS-OriginalClients/${selectedClient.folder}/.metadata.json${AZURE_STORAGE.sasToken}`;
                const response = await fetch(metadataUrl);
                
                if (response.ok) {
                    const metadata = await response.json();
                    selectedClient.description = metadata.description || '';
                    selectedClient.projectType = metadata.projectType || 'Commercial';
                }
            } catch (error) {
                console.log('No metadata found for client, using defaults');
            }
            
            detailsContainer.innerHTML = `
                <div class="form-group">
                    <label>Client Name</label>
                    <input type="text" id="clientName" value="${selectedClient.name}">
                </div>
                <div class="form-group">
                    <label>Folder Name (in Azure)</label>
                    <input type="text" id="folderName" value="${selectedClient.folder}" readonly style="background: #f0f0f0;">
                    <p class="help-text">‚ö†Ô∏è Folder name cannot be changed after creation</p>
                </div>
                <div class="form-group">
                    <label>Project Type</label>
                    <select id="projectType">
                        <option value="Commercial" ${selectedClient.projectType === 'Commercial' ? 'selected' : ''}>Commercial</option>
                        <option value="Residential" ${selectedClient.projectType === 'Residential' ? 'selected' : ''}>Residential</option>
                        <option value="Industrial" ${selectedClient.projectType === 'Industrial' ? 'selected' : ''}>Industrial</option>
                        <option value="Healthcare" ${selectedClient.projectType === 'Healthcare' ? 'selected' : ''}>Healthcare</option>
                        <option value="Educational" ${selectedClient.projectType === 'Educational' ? 'selected' : ''}>Educational</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Description</label>
                    <textarea id="projectDescription">${selectedClient.description || ''}</textarea>
                    <p class="help-text">‚òÅÔ∏è Description is saved in Azure as metadata file</p>
                </div>
                <div style="display: flex; gap: 0.5rem; margin-top: 1rem;">
                    <button class="btn btn-primary" onclick="updateClient()">üíæ Save Changes</button>
                    <button class="btn btn-danger" onclick="deleteClient()">üóëÔ∏è Delete Client</button>
                </div>
            `;
        }

        async function loadClientDocuments() {
            const documentsContainer = document.getElementById('documentManagement');
            showLoading('Loading documents...');
            
            try {
                const prefix = `FCS-OriginalClients/${selectedClient.folder}/`;
                const listUrl = `https://${AZURE_STORAGE.account}.blob.core.windows.net/${AZURE_STORAGE.container}${AZURE_STORAGE.sasToken}&restype=container&comp=list&prefix=${encodeURIComponent(prefix)}`;
                
                const response = await fetch(listUrl);
                const xmlText = await response.text();
                
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const blobs = xmlDoc.getElementsByTagName("Blob");
                
                // Organize documents by category/folder
                const documentsByCategory = {
                    'drawings': [],
                    'estimates': [],
                    'proposals': [],
                    'specs': [],
                    'signed-contracts': [],
                    'documents': [],
                    'other': []
                };
                
                // Parse and categorize documents
                for (let i = 0; i < blobs.length; i++) {
                    const nameEl = blobs[i].getElementsByTagName("Name")[0];
                    const propsEl = blobs[i].getElementsByTagName("Properties")[0];
                    
                    if (nameEl) {
                        const fullPath = nameEl.textContent;
                        const pathParts = fullPath.split('/');
                        
                        // Skip if it's just the folder itself or metadata
                        if (pathParts.length < 3 || fullPath.includes('.metadata')) continue;
                        
                        const category = pathParts[2]; // FCS-OriginalClients/ClientName/Category/file.pdf
                        const fileName = pathParts[pathParts.length - 1];
                        
                        if (fileName && fileName.length > 0 && !fileName.startsWith('.')) {
                            let size = '0 KB';
                            let modified = 'Unknown';
                            
                            if (propsEl) {
                                const sizeEl = propsEl.getElementsByTagName("Content-Length")[0];
                                const modEl = propsEl.getElementsByTagName("Last-Modified")[0];
                                
                                if (sizeEl) {
                                    const bytes = parseInt(sizeEl.textContent) || 0;
                                    size = formatFileSize(bytes);
                                }
                                if (modEl) {
                                    modified = new Date(modEl.textContent).toLocaleDateString();
                                }
                            }
                            
                            const doc = {
                                fullPath: fullPath,
                                fileName: fileName,
                                size: size,
                                modified: modified,
                                category: category
                            };
                            
                            // Add to appropriate category
                            if (documentsByCategory[category]) {
                                documentsByCategory[category].push(doc);
                            } else {
                                documentsByCategory['other'].push(doc);
                            }
                        }
                    }
                }
                
                // Build HTML with categorized documents
                let html = `<h3>üìÑ Documents for ${selectedClient.name}</h3>`;
                
                const totalDocs = Object.values(documentsByCategory).reduce((sum, docs) => sum + docs.length, 0);
                
                if (totalDocs === 0) {
                    html += '<p style="color: var(--steel-gray); text-align: center; padding: 2rem;">No documents found</p>';
                } else {
                    // Category display names and icons
                    const categoryInfo = {
                        'drawings': { name: 'Drawings', icon: 'üìê' },
                        'estimates': { name: 'Estimates', icon: 'üí∞' },
                        'proposals': { name: 'Proposals', icon: 'üìä' },
                        'specs': { name: 'Specifications', icon: 'üìã' },
                        'signed-contracts': { name: 'Signed Contracts', icon: 'üìù' },
                        'documents': { name: 'General Documents', icon: 'üìÅ' },
                        'other': { name: 'Other Files', icon: 'üìé' }
                    };
                    
                    // Display each category
                    for (const [category, docs] of Object.entries(documentsByCategory)) {
                        if (docs.length === 0) continue;
                        
                        const info = categoryInfo[category] || { name: category, icon: 'üìÑ' };
                        
                        html += `
                            <div style="margin-top: 2rem;">
                                <h4 style="color: var(--concrete-gray); border-bottom: 2px solid var(--safety-yellow); padding-bottom: 0.5rem; margin-bottom: 1rem;">
                                    ${info.icon} ${info.name} (${docs.length} files)
                                </h4>
                                <table class="document-table">
                                    <thead>
                                        <tr>
                                            <th>File Name</th>
                                            <th>Size</th>
                                            <th>Modified</th>
                                            <th>Actions</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                        `;
                        
                        for (const doc of docs) {
                            html += `
                                <tr>
                                    <td>${doc.fileName}</td>
                                    <td>${doc.size}</td>
                                    <td>${doc.modified}</td>
                                    <td>
                                        <button class="btn btn-small btn-danger" onclick="deleteDocument('${doc.fullPath}')">üóëÔ∏è Delete</button>
                                    </td>
                                </tr>
                            `;
                        }
                        
                        html += `
                                    </tbody>
                                </table>
                            </div>
                        `;
                    }
                }
                
                documentsContainer.innerHTML = html;
            } catch (error) {
                console.error('Error loading documents:', error);
                documentsContainer.innerHTML = `<p style="color: var(--warning-red);">Error loading documents: ${error.message}</p>`;
            } finally {
                hideLoading();
            }
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i];
        }

        // Client operations
        async function updateClient() {
            const clientData = {
                name: document.getElementById('clientName').value,
                projectType: document.getElementById('projectType').value,
                description: document.getElementById('projectDescription').value,
                lastUpdated: new Date().toISOString()
            };
            
            // Save to Azure Blob Storage as JSON metadata file
            showLoading('Saving client details...');
            try {
                const metadataBlob = new Blob([JSON.stringify(clientData, null, 2)], { type: 'application/json' });
                const metadataUrl = `https://${AZURE_STORAGE.account}.blob.core.windows.net/${AZURE_STORAGE.container}/FCS-OriginalClients/${selectedClient.folder}/.metadata.json${AZURE_STORAGE.sasToken}`;
                
                const response = await fetch(metadataUrl, {
                    method: 'PUT',
                    headers: {
                        'x-ms-blob-type': 'BlockBlob',
                        'Content-Type': 'application/json'
                    },
                    body: metadataBlob
                });
                
                if (response.ok || response.status === 201) {
                    // Update in memory
                    selectedClient.name = clientData.name;
                    selectedClient.projectType = clientData.projectType;
                    selectedClient.description = clientData.description;
                    
                    showStatus('success', 'Client details saved to Azure successfully');
                    renderClients();
                } else {
                    throw new Error('Failed to save metadata');
                }
            } catch (error) {
                showStatus('error', `Failed to save: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        async function deleteClient() {
            if (!confirm(`Delete client "${selectedClient.name}"? This will delete all documents and cannot be undone.`)) {
                return;
            }
            
            showLoading('Deleting client and all associated files...');
            try {
                // Use n8n webhook for complete client deletion including index updates
                const response = await fetch('https://workflows.saxtechnology.com/webhook/ask-foreman/clients/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        clientName: selectedClient.folder,
                        // Additional context for n8n workflow
                        source: 'admin-panel',
                        timestamp: new Date().toISOString()
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showStatus('success', `Client deleted successfully. All files and index entries removed.`);
                    selectedClient = null;
                    loadClients();
                    // Clear the details panel
                    document.getElementById('clientDetails').innerHTML = '<p style="color: var(--steel-gray); text-align: center; padding: 2rem;">Select a client from the list to view details</p>';
                    document.getElementById('documentManagement').innerHTML = '<p style="color: var(--steel-gray); text-align: center; padding: 2rem;">Select a client to manage documents</p>';
                } else {
                    const errorText = await response.text();
                    showStatus('error', `Failed to delete client: ${errorText}`);
                }
            } catch (error) {
                showStatus('error', `Failed to delete client: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        function createNewClient() {
            const name = prompt('Enter client name:');
            if (!name) return;
            
            showStatus('success', `To create client "${name}", use the main app's "Create New Client" feature`);
        }

        // Document operations
        async function deleteDocument(filePath) {
            if (!confirm(`Delete this document?\n\nFile: ${filePath.split('/').pop()}`)) {
                return;
            }
            
            showLoading('Deleting document...');
            try {
                // Extract file ID from path for n8n webhook
                // Path format: FCS-OriginalClients/ClientName/Category/filename.ext
                const pathParts = filePath.split('/');
                const clientName = pathParts[1];
                const category = pathParts[2];
                const fileName = pathParts[pathParts.length - 1];
                
                // Use n8n webhook for file deletion with proper index cleanup
                const webhookUrl = `https://workflows.saxtechnology.com/webhook/ask-foreman-delete-file/ask-foreman/files/${encodeURIComponent(filePath)}`;
                
                const response = await fetch(webhookUrl, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        filePath: filePath,
                        clientName: clientName,
                        category: category,
                        fileName: fileName,
                        source: 'admin-panel',
                        timestamp: new Date().toISOString()
                    })
                });
                
                if (response.ok) {
                    showStatus('success', 'Document deleted successfully from storage and index');
                    loadClientDocuments();
                } else {
                    // Fallback to direct blob deletion if webhook fails
                    console.warn('Webhook deletion failed, attempting direct blob deletion');
                    const deleteUrl = `https://${AZURE_STORAGE.account}.blob.core.windows.net/${AZURE_STORAGE.container}/${filePath}${AZURE_STORAGE.sasToken}`;
                    
                    const directResponse = await fetch(deleteUrl, {
                        method: 'DELETE',
                        headers: {
                            'x-ms-delete-snapshots': 'include'
                        }
                    });
                    
                    if (directResponse.ok || directResponse.status === 202) {
                        showStatus('warning', 'Document deleted from storage (index may not be updated)');
                        loadClientDocuments();
                    } else {
                        throw new Error(`Delete failed with status ${directResponse.status}`);
                    }
                }
            } catch (error) {
                showStatus('error', `Failed to delete: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // System operations
        async function syncAzureStorage() {
            if (!confirm(`Sync with Azure Storage?\n\nWhat this does:\n- Scans all folders in Azure Blob Storage\n- Updates the client list\n- Identifies new or removed clients\n- Refreshes document counts\n\nUse this when files were added/removed outside the app.`)) {
                return;
            }
            
            await loadClients();
            showStatus('success', `Azure Storage synced. Found ${clients.length} clients.`);
        }

        function exportClientData() {
            const dataStr = JSON.stringify(clients, null, 2);
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            
            const exportFileDefaultName = `clients_${new Date().toISOString().split('T')[0]}.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            showStatus('success', 'Client data exported');
        }

        // Store selected files for preview
        let selectedFiles = [];
        
        // Enhanced bulk upload with preview and 15-file limit
        function handleBulkFilesWithPreview(event) {
            const files = event.target.files;
            if (!files || files.length === 0) return;
            
            if (!selectedClient) {
                showStatus('error', 'Please select a client first');
                event.target.value = '';
                return;
            }
            
            // Check file limit
            if (files.length > MAX_FILES_PER_UPLOAD) {
                showStatus('warning', `You selected ${files.length} files. Maximum ${MAX_FILES_PER_UPLOAD} files allowed per upload. Please select fewer files.`);
                event.target.value = '';
                return;
            }
            
            // Store files for preview
            selectedFiles = Array.from(files);
            
            // Get default category
            const defaultCategory = document.querySelector('input[name="uploadCategory"]:checked')?.value || 'drawings';
            
            // Build preview UI
            const fileListContainer = document.getElementById('fileList');
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr>';
            html += '<th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid var(--medium-gray);">File Name</th>';
            html += '<th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid var(--medium-gray);">Size</th>';
            html += '<th style="padding: 0.5rem; text-align: left; border-bottom: 2px solid var(--medium-gray);">Category</th>';
            html += '</tr></thead><tbody>';
            
            selectedFiles.forEach((file, index) => {
                const fileName = file.name;
                const fileSize = formatFileSize(file.size);
                
                const selectedCategory = defaultCategory;
                
                html += '<tr>';
                html += `<td style="padding: 0.5rem; border-bottom: 1px solid var(--light-gray);">${fileName}</td>`;
                html += `<td style="padding: 0.5rem; border-bottom: 1px solid var(--light-gray);">${fileSize}</td>`;
                html += `<td style="padding: 0.5rem; border-bottom: 1px solid var(--light-gray);">`;
                html += `<select id="fileCategory_${index}" style="padding: 0.25rem; border: 1px solid var(--medium-gray); border-radius: 3px;">`;
                html += `<option value="drawings" ${selectedCategory === 'drawings' ? 'selected' : ''}>üìê Drawings</option>`;
                html += `<option value="estimates" ${selectedCategory === 'estimates' ? 'selected' : ''}>üí∞ Estimates</option>`;
                html += `<option value="proposals" ${selectedCategory === 'proposals' ? 'selected' : ''}>üìä Proposals</option>`;
                html += `<option value="specs" ${selectedCategory === 'specs' ? 'selected' : ''}>üìã Specs</option>`;
                html += `<option value="signed-contracts" ${selectedCategory === 'signed-contracts' ? 'selected' : ''}>üìù Contracts</option>`;
                html += `</select>`;
                html += `</td>`;
                html += '</tr>';
            });
            
            html += '</tbody></table>';
            html += `<p style="margin-top: 0.5rem; color: var(--steel-gray); font-size: 0.9rem;">Total files: ${selectedFiles.length} / ${MAX_FILES_PER_UPLOAD} max</p>`;
            fileListContainer.innerHTML = html;
            
            // Show preview area
            document.getElementById('filePreviewArea').style.display = 'block';
            
            // Clear file input to allow re-selection
            event.target.value = '';
        }
        
        // Upload files with individual categories using n8n webhook for conversion
        async function uploadFilesWithCategories() {
            if (!selectedFiles || selectedFiles.length === 0) {
                showStatus('error', 'No files selected');
                return;
            }
            
            if (!selectedClient) {
                showStatus('error', 'Please select a client first');
                return;
            }
            
            showLoading(`Uploading and converting ${selectedFiles.length} files...`);
            
            let successCount = 0;
            let errorCount = 0;
            const errors = [];
            
            // Use n8n webhook for upload and conversion
            // Using regular upload endpoint since we're sending files one by one
            const uploadWebhookUrl = 'https://workflows.saxtechnology.com/webhook/ask-foreman/upload';
            
            for (let i = 0; i < selectedFiles.length; i++) {
                const file = selectedFiles[i];
                const fileName = file.name;
                
                // Get category from dropdown
                const categorySelect = document.getElementById(`fileCategory_${i}`);
                const category = categorySelect ? categorySelect.value : 'drawings';
                
                try {
                    console.log(`Uploading ${fileName} to category: ${category}`);
                    console.log('Selected client:', selectedClient);
                    console.log('Client folder:', selectedClient.folder);
                    
                    // Create FormData for n8n webhook
                    const formData = new FormData();
                    formData.append('file', file);
                    formData.append('category', category);
                    formData.append('client', selectedClient.folder || selectedClient.name);
                    formData.append('clientName', selectedClient.folder || selectedClient.name); // Add clientName as well
                    formData.append('fileName', fileName);
                    formData.append('source', 'admin-bulk-upload');
                    
                    // Send to n8n webhook for processing and conversion
                    const uploadResponse = await fetch(uploadWebhookUrl, {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (uploadResponse.ok) {
                        const result = await uploadResponse.json();
                        console.log(`Successfully uploaded ${fileName}:`, result);
                        successCount++;
                    } else {
                        const errorText = await uploadResponse.text();
                        console.error(`Failed to upload ${fileName}:`, errorText);
                        errors.push(`${fileName}: ${errorText}`);
                        errorCount++;
                    }
                } catch (error) {
                    console.error(`Error uploading ${fileName}:`, error);
                    errors.push(`${fileName}: ${error.message}`);
                    errorCount++;
                }
                
                document.getElementById('loadingText').textContent = `Processing file ${i + 1} of ${selectedFiles.length}...`;
            }
            
            hideLoading();
            
            // Show results
            let message = '';
            if (successCount > 0) {
                message = `‚úÖ Successfully uploaded and converted ${successCount} file(s). They will be indexed for search.`;
            }
            if (errorCount > 0) {
                message += `\n‚ö†Ô∏è ${errorCount} file(s) failed to upload.`;
                if (errors.length > 0) {
                    console.error('Upload errors:', errors);
                }
            }
            
            showStatus(errorCount > 0 ? 'warning' : 'success', message);
            
            // Clear selection and hide preview
            clearFileSelection();
            
            // Reload documents after a delay to allow conversion
            setTimeout(() => {
                loadClientDocuments();
            }, 2000);
        }
        
        // Clear file selection
        function clearFileSelection() {
            selectedFiles = [];
            document.getElementById('filePreviewArea').style.display = 'none';
            document.getElementById('bulkFileInput').value = '';
        }
        
        // Drag and drop with file limit check
        const bulkUploadArea = document.getElementById('bulkUploadArea');
        
        bulkUploadArea?.addEventListener('dragover', (e) => {
            e.preventDefault();
            bulkUploadArea.classList.add('dragover');
        });
        
        bulkUploadArea?.addEventListener('dragleave', () => {
            bulkUploadArea.classList.remove('dragover');
        });
        
        bulkUploadArea?.addEventListener('drop', (e) => {
            e.preventDefault();
            bulkUploadArea.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                // Check file limit before processing
                if (files.length > MAX_FILES_PER_UPLOAD) {
                    showStatus('warning', `You dropped ${files.length} files. Maximum ${MAX_FILES_PER_UPLOAD} files allowed per upload. Please select fewer files.`);
                    return;
                }
                handleBulkFilesWithPreview({ target: { files } });
            }
        });

        // UI helpers
        function showLoading(text = 'Loading...') {
            document.getElementById('loadingText').textContent = text;
            document.getElementById('loadingOverlay').style.display = 'flex';
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function showStatus(type, message) {
            const statusEl = document.getElementById('statusMessage');
            statusEl.textContent = message;
            statusEl.className = `status-message status-${type}`;
            statusEl.style.display = 'block';
            
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, type === 'warning' ? 7000 : 5000); // Longer display for warnings
        }

        // Azure Search Index Management Functions
        // Using n8n webhooks as proxy to avoid CORS issues
        const AZURE_SEARCH_PROXY = {
            statsUrl: 'https://workflows.saxtechnology.com/webhook/ask-foreman/index/stats',
            searchUrl: 'https://workflows.saxtechnology.com/webhook/ask-foreman/index/search',
            deleteUrl: 'https://workflows.saxtechnology.com/webhook/ask-foreman/index/delete',
            clearUrl: 'https://workflows.saxtechnology.com/webhook/ask-foreman/index/clear'
        };

        // View index contents and statistics
        async function viewIndexContents(forceRefresh = false) {
            showLoading('Fetching index contents...');
            
            try {
                // First, if force refresh, try to trigger Azure Search to update its stats
                if (forceRefresh) {
                    console.log('Force refreshing index statistics...');
                    // Clear any cached data
                    window.lastKnownDocumentCount = null;
                    
                    // Make a dummy search query to potentially trigger stats update
                    try {
                        await fetch(AZURE_SEARCH_PROXY.searchUrl, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                                // Removed 'Pragma' header to avoid CORS issues
                            },
                            body: JSON.stringify({ search: '*', top: 1, count: true })
                        });
                    } catch (e) {
                        console.log('Stats refresh query failed, continuing...');
                    }
                    // Increased delay to let Azure process
                    await new Promise(resolve => setTimeout(resolve, 1000));
                }
                
                // Get index statistics via n8n proxy with aggressive cache busting
                const randomId = Math.random().toString(36).substring(7);
                const statsUrl = `${AZURE_SEARCH_PROXY.statsUrl}?t=${Date.now()}&r=${randomId}&force=${forceRefresh}&_=${Math.random()}`;
                const statsResponse = await fetch(statsUrl, {
                    method: 'GET',  // Always use GET for stats endpoint
                    headers: {
                        'Content-Type': 'application/json',
                        'Cache-Control': 'no-cache, no-store, must-revalidate'
                    },
                    cache: 'no-store'
                });
                
                if (statsResponse.ok) {
                    let statsData = await statsResponse.json();
                    console.log('Raw stats response:', statsData); // Debug log
                    console.log('Stats fetch time:', new Date().toISOString());
                    
                    // Handle if response is wrapped in array
                    const stats = Array.isArray(statsData) ? statsData[0] : statsData;
                    console.log('Index stats parsed:', stats); // Debug log
                    
                    // Check if stats are stale by comparing with actual document count
                    const actualDocCount = window.lastKnownDocumentCount || 0;
                    if (actualDocCount > 0 && stats.documentCount !== actualDocCount) {
                        console.warn(`Stats mismatch: API says ${stats.documentCount}, but we counted ${actualDocCount} documents`);
                    }
                    
                    const indexStats = document.getElementById('indexStats');
                    document.getElementById('indexDocCount').textContent = `Documents: ${stats.documentCount || 0}`;
                    document.getElementById('indexSize').textContent = `Size: ${formatFileSize(stats.storageSize || 0)}`;
                    document.getElementById('indexLastUpdate').textContent = `Last Updated: ${new Date().toLocaleString()}`;
                    indexStats.style.display = 'block';
                    
                    // Add refresh button if not already there
                    if (!document.getElementById('refreshStatsBtn')) {
                        const refreshBtn = document.createElement('button');
                        refreshBtn.id = 'refreshStatsBtn';
                        refreshBtn.className = 'btn btn-small';
                        refreshBtn.style.cssText = 'margin-left: 10px; padding: 2px 8px; font-size: 12px;';
                        refreshBtn.innerHTML = 'üîÑ Force Refresh';
                        refreshBtn.onclick = () => viewIndexContents(true);
                        document.getElementById('indexDocCount').parentElement.insertBefore(refreshBtn, document.getElementById('indexDocCount').nextSibling);
                    }
                } else {
                    console.error('Failed to fetch stats:', await statsResponse.text());
                }
                
                    // Search for all documents via n8n proxy
                // Request ALL fields to see what's actually in the index
                const searchCacheBuster = `${Date.now()}_${Math.random()}`;
                const searchResponse = await fetch(`${AZURE_SEARCH_PROXY.searchUrl}?cb=${searchCacheBuster}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        search: '*',
                        top: 1000,  // Increased to get more documents
                        select: '*',  // Get ALL fields to inspect what's in the index
                        count: true,
                        orderby: 'fileName desc'  // Order by filename to see latest
                    }),
                    cache: 'no-store'
                });
                
                if (searchResponse.ok) {
                    let searchResults;
                    try {
                        // Clone response to read it multiple ways if needed
                        const clonedResponse = searchResponse.clone();
                        
                        // Try to get response text
                        const responseText = await searchResponse.text();
                        console.log('Raw response text:', responseText);
                        console.log('Response length:', responseText.length);
                        console.log('Response headers:', searchResponse.headers);
                        
                        if (!responseText || responseText.length === 0) {
                            console.error('Empty response received');
                            // Try reading the cloned response as JSON directly
                            try {
                                searchResults = await clonedResponse.json();
                                console.log('Cloned response JSON:', searchResults);
                            } catch (e) {
                                console.error('Cloned response also failed:', e);
                                searchResults = { value: [] };
                            }
                        } else {
                            searchResults = JSON.parse(responseText);
                        }
                    } catch (parseError) {
                        console.error('Failed to parse response:', parseError);
                        searchResults = { value: [] };
                    }
                    const documents = searchResults.value || [];
                    
                    // Store actual document count for comparison with stats
                    window.lastKnownDocumentCount = documents.length;
                    
                    console.log('Search results:', searchResults); // Debug log
                    console.log('Actual document count:', documents.length); // Compare with stats
                    
                    // Log first document to see what fields are actually stored
                    if (documents.length > 0) {
                        console.log('First document structure:', documents[0]);
                        console.log('Document keys:', Object.keys(documents[0]));
                        
                        // Check if content field exists and what it contains
                        if (documents[0].content) {
                            console.log('Content field preview (first 500 chars):', documents[0].content.substring(0, 500));
                        } else {
                            console.log('No content field found in document');
                        }
                    }
                    
                    // Build document display
                    const indexContents = document.getElementById('indexContents');
                    
                    if (documents.length === 0) {
                        indexContents.innerHTML = '<p style="text-align: center; padding: 1rem; color: var(--steel-gray);">No documents in index</p>';
                    } else {
                        // Categorize documents
                        const problematicDocs = [];
                        const validDocs = [];
                        const processingDocs = [];
                        
                        documents.forEach(doc => {
                            const fileName = doc.fileName || 'Unknown';
                            const client = doc.client;
                            
                            // Identify different document types
                            const hasNoClient = !client || client === 'Unknown' || client === 'null';
                            const isPlaceholder = fileName === '.placeholder';
                            const isProcessingMetadata = fileName.includes('.metadata.json'); // Processing metadata, not useful
                            const isProcessedContent = fileName.includes('.jsonl'); // Processed content - SHOULD be indexed
                            const isClientInfo = fileName === 'client-info.json'; // Client metadata - useful for context
                            
                            // Only truly problematic files
                            const isProblematic = 
                                isPlaceholder || // Empty placeholder files
                                isProcessingMetadata || // Processing metadata files
                                (hasNoClient && !isClientInfo); // Files with no client (except client-info.json)
                            
                            if (isProblematic) {
                                problematicDocs.push(doc);
                            } else if (isProcessedContent || isClientInfo) {
                                // These are processing/metadata files that ARE useful
                                processingDocs.push(doc);
                            } else {
                                validDocs.push(doc);
                            }
                        });
                        
                        let html = '<div style="margin-bottom: 1rem;">';
                        html += `<div style="display: flex; gap: 1.5rem; margin-bottom: 1rem; flex-wrap: wrap;">`;
                        html += `<span style="color: var(--hi-vis-green);">‚úÖ Original Documents: ${validDocs.length}</span>`;
                        html += `<span style="color: var(--blueprint-blue);">üîÑ Processed Content: ${processingDocs.length}</span>`;
                        html += `<span style="color: var(--warning-red);">‚ö†Ô∏è Issues: ${problematicDocs.length}</span>`;
                        html += `<span style="color: var(--steel-gray);">üìä Total: ${documents.length}</span>`;
                        html += `</div>`;
                        
                        // Show warning only for real issues
                        const unknownClientDocs = documents.filter(d => !d.client || d.client === 'Unknown' || d.client === 'null');
                        const placeholderDocs = documents.filter(d => d.fileName === '.placeholder');
                        
                        if (unknownClientDocs.length > 0 || placeholderDocs.length > 0) {
                            html += '<div style="background: #ffebee; border: 1px solid #f44336; border-radius: 5px; padding: 0.75rem; margin-bottom: 1rem;">';
                            html += '<strong>üö® Critical Issues:</strong><br>';
                            if (unknownClientDocs.length > 0) {
                                html += `‚Ä¢ ${unknownClientDocs.length} documents with missing client information (breaks deletion/filtering)<br>`;
                            }
                            if (placeholderDocs.length > 0) {
                                html += `‚Ä¢ ${placeholderDocs.length} empty placeholder files<br>`;
                            }
                            html += '<br><strong>Root Cause:</strong> The n8n workflow is not properly setting the client field during upload.<br>';
                            html += '<button class="btn btn-danger" style="margin-top: 0.5rem;" onclick="cleanupProblematicDocs()">üóëÔ∏è Remove Problematic Documents</button>';
                            html += '</div>';
                        }
                        
                        if (processingDocs.length > 0) {
                            html += '<div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 5px; padding: 0.75rem; margin-bottom: 1rem;">';
                            html += '<strong>‚ÑπÔ∏è Processing Files:</strong><br>';
                            html += `‚Ä¢ ${processingDocs.filter(d => d.fileName.includes('.jsonl')).length} JSONL files (processed document content)<br>`;
                            html += `‚Ä¢ ${processingDocs.filter(d => d.fileName === 'client-info.json').length} client info files (project metadata)<br>`;
                            html += 'These files contain searchable content and metadata - they are working as intended.';
                            html += '</div>';
                        }
                        html += '</div>';
                        
                        html += '<table class="document-table" style="width: 100%;">';
                        html += '<thead><tr>';
                        html += '<th style="width: 20px;"><input type="checkbox" id="selectAllDocs" onchange="toggleAllDocuments()"></th>';
                        html += '<th>File Name</th>';
                        html += '<th>Client</th>';
                        html += '<th>Category</th>';
                        html += '<th>Size</th>';
                        html += '<th>Uploaded</th>';
                        html += '<th>Type</th>';
                        html += '<th>Status</th>';
                        html += '</tr></thead><tbody>';
                        
                        documents.forEach((doc, index) => {
                            const fileName = doc.fileName || 'Unknown';
                            const client = doc.client || 'Unknown';
                            const category = doc.category || 'documents';
                            
                            // Calculate content size
                            let contentSize = 0;
                            if (doc.content) {
                                contentSize = new Blob([doc.content]).size;
                            }
                            
                            // Format upload date
                            let uploadDate = 'Unknown';
                            if (doc.uploadedAt) {
                                uploadDate = new Date(doc.uploadedAt).toLocaleDateString();
                            }
                            
                            // Check what type of content is stored
                            let contentType = 'Unknown';
                            let rowClass = '';
                            let statusIcon = '‚úÖ';
                            
                            // Identify document types and issues
                            if (fileName === '.placeholder') {
                                contentType = 'üìÇ Placeholder';
                                rowClass = 'style="background-color: #ffebee;"';
                                statusIcon = '‚ùå';
                            } else if (fileName.includes('.metadata.json')) {
                                contentType = '‚öôÔ∏è Processing Metadata';
                                rowClass = 'style="background-color: #fff3e0;"';
                                statusIcon = '‚ö†Ô∏è';
                            } else if (fileName.includes('.jsonl')) {
                                contentType = 'üìÑ Processed Content';
                                rowClass = 'style="background-color: #e3f2fd;"';
                                statusIcon = 'üîÑ';
                            } else if (fileName === 'client-info.json') {
                                contentType = 'üìã Client Info';
                                rowClass = 'style="background-color: #e8f5e9;"';
                                statusIcon = '‚ÑπÔ∏è';
                            } else if (!client || client === 'Unknown' || client === 'null') {
                                rowClass = 'style="background-color: #ffebee;"';
                                statusIcon = 'üö®';
                            } else if (doc.content) {
                                // Check if content looks like JSON
                                if (doc.content.trim().startsWith('{') || doc.content.trim().startsWith('[')) {
                                    contentType = 'üìÑ JSON';
                                } else if (doc.content.includes('=== DOCUMENT ANALYSIS ===')) {
                                    contentType = 'üìù Processed';
                                } else if (doc.content.includes('\n\n') && doc.content.includes(':')) {
                                    contentType = 'üìù Text/Markdown';
                                } else {
                                    contentType = 'üìÉ Text';
                                }
                            } else {
                                contentType = '‚ùå No content';
                                rowClass = 'style="background-color: #ffebee;"';
                                statusIcon = '‚ö†Ô∏è';
                            }
                            
                            html += `<tr ${rowClass}>`;
                            html += `<td><input type="checkbox" class="doc-checkbox" value="${doc.id}" data-filename="${fileName}" data-problematic="${rowClass ? 'true' : 'false'}"></td>`;
                            html += `<td title="${fileName}" style="max-width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${fileName}</td>`;
                            html += `<td>${client}</td>`;
                            html += `<td>${category}</td>`;
                            html += `<td>${formatFileSize(contentSize)}</td>`;
                            html += `<td>${uploadDate}</td>`;
                            html += `<td>${contentType}</td>`;
                            html += `<td style="text-align: center;">${statusIcon}</td>`;
                            html += '</tr>';
                        });
                        
                        html += '</tbody></table>';
                        html += '<div style="margin-top: 1rem; display: flex; gap: 0.5rem; align-items: center;">';
                        html += '<button class="btn btn-danger" onclick="deleteSelectedDocuments()">üóëÔ∏è Delete Selected</button>';
                        html += '<button class="btn btn-warning" onclick="selectProblematicDocs()">‚ö†Ô∏è Select Problematic</button>';
                        html += '<button class="btn" onclick="viewIndexContents(true)">üîÑ Refresh</button>';
                        html += `<span style="color: var(--steel-gray); margin-left: auto;">Total: ${documents.length} documents in index</span>`;
                        html += '</div>';
                        
                        indexContents.innerHTML = html;
                    }
                    
                    indexContents.style.display = 'block';
                } else {
                    const errorText = await searchResponse.text();
                    console.error('Search API error:', errorText);
                    throw new Error(`Failed to fetch index contents: ${errorText}`);
                }
                
            } catch (error) {
                console.error('Error viewing index:', error);
                showStatus('error', `Failed to fetch index contents: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Toggle all document checkboxes
        function toggleAllDocuments() {
            const selectAll = document.getElementById('selectAllDocs');
            const checkboxes = document.querySelectorAll('.doc-checkbox');
            checkboxes.forEach(cb => cb.checked = selectAll.checked);
        }

        // Delete selected documents from index
        async function deleteSelectedDocuments() {
            const checkboxes = document.querySelectorAll('.doc-checkbox:checked');
            if (checkboxes.length === 0) {
                showStatus('warning', 'Please select documents to delete');
                return;
            }
            
            const fileNames = Array.from(checkboxes).map(cb => cb.getAttribute('data-filename')).filter(name => name !== 'Unknown');
            const confirmMsg = `Delete ${checkboxes.length} selected document(s) from the search index?\n\nFiles:\n${fileNames.slice(0, 5).join('\n')}${fileNames.length > 5 ? `\n... and ${fileNames.length - 5} more` : ''}`;
            
            if (!confirm(confirmMsg)) return;
            
            showLoading(`Deleting ${checkboxes.length} documents from index...`);
            
            try {
                const documentIds = Array.from(checkboxes).map(cb => cb.value);
                
                // Delete via n8n proxy
                const response = await fetch(AZURE_SEARCH_PROXY.deleteUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        documentIds: documentIds
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    showStatus('success', `Successfully deleted ${checkboxes.length} document(s) from the index`);
                    
                    // Clear cache and refresh the entire view including stats with force refresh
                    window.lastKnownDocumentCount = null;
                    setTimeout(() => viewIndexContents(true), 2000);
                } else {
                    const errorText = await response.text();
                    throw new Error(errorText);
                }
                
            } catch (error) {
                console.error('Error deleting documents:', error);
                showStatus('error', `Failed to delete documents: ${error.message}`);
            } finally {
                hideLoading();
            }
        }

        // Select all problematic documents
        function selectProblematicDocs() {
            const checkboxes = document.querySelectorAll('.doc-checkbox');
            checkboxes.forEach(cb => {
                cb.checked = cb.getAttribute('data-problematic') === 'true';
            });
            
            const checkedCount = document.querySelectorAll('.doc-checkbox:checked').length;
            if (checkedCount > 0) {
                showStatus('info', `Selected ${checkedCount} problematic documents`);
            }
        }
        
        // Clean up problematic documents from index
        async function cleanupProblematicDocs() {
            showLoading('Analyzing index for cleanup...');
            
            try {
                // Get all documents
                const searchResponse = await fetch(AZURE_SEARCH_PROXY.searchUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        search: '*',
                        top: 1000,
                        select: 'id,fileName,client,category',
                        count: true
                    })
                });
                
                if (!searchResponse.ok) {
                    throw new Error('Failed to fetch documents');
                }
                
                const searchResults = await searchResponse.json();
                const documents = searchResults.value || [];
                
                // Identify truly problematic documents (not all metadata)
                const problematicIds = [];
                documents.forEach(doc => {
                    const fileName = doc.fileName || '';
                    const client = doc.client;
                    
                    // Only remove truly problematic files:
                    // 1. Placeholder files (empty)
                    // 2. Documents with no client info (except client-info.json which is OK)
                    // 3. Processing metadata files (.metadata.json) but NOT content files (.jsonl)
                    const isProblematic = 
                        fileName === '.placeholder' || // Empty placeholders
                        ((!client || client === 'Unknown' || client === 'null') && fileName !== 'client-info.json') || // Missing client
                        fileName.includes('.metadata.json'); // Processing metadata only
                    
                    // Note: We KEEP .jsonl files as they contain the actual processed content
                    // Note: We KEEP client-info.json as it contains useful project metadata
                    
                    if (isProblematic) {
                        problematicIds.push(doc.id);
                    }
                });
                
                if (problematicIds.length === 0) {
                    hideLoading();
                    showStatus('success', 'No problematic documents found in index');
                    return;
                }
                
                if (!confirm(`Found ${problematicIds.length} problematic documents.\n\nThis will remove:\n‚Ä¢ Empty placeholder files\n‚Ä¢ Documents with missing client information\n‚Ä¢ Processing metadata files (.metadata.json)\n\nThis will KEEP:\n‚Ä¢ JSONL files (processed document content)\n‚Ä¢ client-info.json files (project metadata)\n\nDelete problematic documents?`)) {
                    hideLoading();
                    return;
                }
                
                showLoading(`Deleting ${problematicIds.length} problematic documents...`);
                
                // Delete in batches
                const batchSize = 50;
                let deletedCount = 0;
                
                for (let i = 0; i < problematicIds.length; i += batchSize) {
                    const batch = problematicIds.slice(i, i + batchSize);
                    
                    const deleteResponse = await fetch(AZURE_SEARCH_PROXY.deleteUrl, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            documentIds: batch
                        })
                    });
                    
                    if (deleteResponse.ok) {
                        deletedCount += batch.length;
                        showLoading(`Deleted ${deletedCount} of ${problematicIds.length} documents...`);
                    }
                }
                
                hideLoading();
                showStatus('success', `Successfully cleaned up ${deletedCount} problematic documents from the index`);
                
                // Refresh the view
                setTimeout(() => viewIndexContents(true), 2000);
                
            } catch (error) {
                hideLoading();
                console.error('Cleanup error:', error);
                showStatus('error', `Cleanup failed: ${error.message}`);
            }
        }
        
        // Clear entire index
        async function confirmClearIndex() {
            // First, get the document count
            showLoading('Checking index...');
            
            try {
                // Get stats via n8n proxy
                const statsResponse = await fetch(AZURE_SEARCH_PROXY.statsUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                
                let docCount = 0;
                if (statsResponse.ok) {
                    let statsData = await statsResponse.json();
                    // Handle if response is wrapped in array
                    const stats = Array.isArray(statsData) ? statsData[0] : statsData;
                    docCount = stats.documentCount || 0;
                }
                
                hideLoading();
                
                if (docCount === 0) {
                    showStatus('warning', 'The index is already empty');
                    return;
                }
                
                const confirmMsg = `‚ö†Ô∏è WARNING: Clear the ENTIRE search index?\n\nThis will delete ALL ${docCount} indexed documents from search.\nThe original files in Azure Storage will NOT be affected.\n\nThis action cannot be undone!\n\nType "CLEAR INDEX" to confirm:`;
                
                const userConfirmation = prompt(confirmMsg);
                
                if (userConfirmation !== 'CLEAR INDEX') {
                    showStatus('warning', 'Index clear cancelled');
                    return;
                }
                
                await clearEntireIndex();
                
            } catch (error) {
                hideLoading();
                console.error('Error checking index:', error);
                showStatus('error', `Failed to check index: ${error.message}`);
            }
        }

        // Actually clear the entire index
        async function clearEntireIndex() {
            showLoading('Clearing entire index... This may take a moment...');
            
            try {
                // Clear entire index via n8n proxy
                const response = await fetch(AZURE_SEARCH_PROXY.clearUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({})
                });
                
                if (!response.ok) {
                    throw new Error('Failed to clear index');
                }
                
                const result = await response.json();
                const deletedCount = result.deletedCount || 0;
                
                hideLoading();
                showStatus('success', `Successfully cleared the entire index. ${deletedCount} documents removed.`);
                
                // Clear the display and refresh stats
                document.getElementById('indexContents').innerHTML = '<p style="text-align: center; padding: 1rem; color: var(--steel-gray);">Index has been cleared</p>';
                
                // Refresh stats to show 0 documents
                setTimeout(async () => {
                    try {
                        const statsResponse = await fetch(AZURE_SEARCH_PROXY.statsUrl, {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json'
                            }
                        });
                        
                        if (statsResponse.ok) {
                            let statsData = await statsResponse.json();
                            // Handle if response is wrapped in array
                            const stats = Array.isArray(statsData) ? statsData[0] : statsData;
                            const indexStats = document.getElementById('indexStats');
                            document.getElementById('indexDocCount').textContent = `Documents: ${stats.documentCount || 0}`;
                            document.getElementById('indexSize').textContent = `Size: ${formatFileSize(stats.storageSize || 0)}`;
                            document.getElementById('indexLastUpdate').textContent = `Last Updated: ${new Date().toLocaleString()}`;
                            indexStats.style.display = 'block';
                        }
                    } catch (error) {
                        console.error('Error refreshing stats:', error);
                    }
                }, 500);
                
            } catch (error) {
                console.error('Error clearing index:', error);
                showStatus('error', `Failed to clear index: ${error.message}`);
                hideLoading();
            }
        }
    </script>
</body>
</html>
